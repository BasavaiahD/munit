/**
 * Mule Development Kit
 * Copyright 2010-2011 (c) MuleSoft, Inc.  All rights reserved.  http://www.mulesoft.com
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This file was automatically generated by the Mule Development Kit
 */
package org.mule.munit;

import au.com.bytecode.opencsv.CSVWriter;
import org.apache.log4j.Logger;
import org.h2.tools.RunScript;
import org.mule.api.annotations.Configurable;
import org.mule.api.annotations.Module;
import org.mule.api.annotations.Processor;
import org.mule.api.annotations.param.Optional;

import java.io.*;
import java.net.URISyntaxException;
import java.sql.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static junit.framework.Assert.assertEquals;

/**
 * <p>Module to test database connections</p>
 *
 * @author Federico, Fernando
 * @author Casal, Javier
 */
@Module(name="dbserver", schemaVersion="1.0")
public class DBServerModule
{
    /**
     * <p>H2 Database name</p>
     */
    @Configurable
    private String database;

    /**
     * <p>Name of (or path to) the SQL file whose statements will be executed when the database is started</p>
     */
    @Configurable
    @Optional
    private String sqlFile;

    /**
     * <p>CSV files (separated by semicolon) that creates tables in the database using the file name (without the
     * termination, ".csv") as the table name and its columns as the table columns</p>
     */
    @Configurable
    @Optional
    private String csv;


    private Connection connection;
    static Logger logger = Logger.getLogger(DBServerModule.class);


    /**
     * <p>Starts the server</p>
     * <p>Executes the correspondent queries if an SQL file has been included in the dbserver configuration</p>
     * <p>Creates the correspondent tables in the database if a CSV file has been included in the dbserver
     * configuration</p>
     *
     * {@sample.xml ../../../doc/DBServer-connector.xml.sample dbserver:start}
     *
     */
    @Processor
    public void startDbServer()
    {
        try
        {
            addJdbcToClassLoader();
            connection = DriverManager.getConnection("jdbc:h2:mem:"+ database);
            executeQueriesFromSQLFile(connection);
            Statement stmt = connection.createStatement();
            createTablesFromCsv(stmt);
        }
        catch (Exception e)
        {
            throw new RuntimeException("Could not start the database server", e);
        }
    }

    private void executeQueriesFromSQLFile(Connection conn) throws SQLException, FileNotFoundException
    {
        if(sqlFile != null)
        {
            InputStream streamImput = getClass().getResourceAsStream(File.separator + sqlFile);
            RunScript.execute(conn, new InputStreamReader(streamImput));
        }
    }

    private void createTablesFromCsv(Statement stmt)
    {
        if (csv != null)
        {
            String[] tables = csv.split(";");
            for ( String table : tables )
            {
                String tableName = table.replaceAll(".csv", "");
                try
                {
                    stmt.execute("CREATE TABLE "+tableName+" AS SELECT * FROM CSVREAD(\'" + getClass().
                            getResource("/"+table).toURI().toASCIIString()  + "\');");
                }
                catch (SQLException e)
                {
                    throw new RuntimeException("Invalid SQL, could not create table " + tableName + " from " + table);
                }
                catch (URISyntaxException e)
                {
                    throw new RuntimeException("Could not read file " + table);
                }
            }
        }
    }


    /**
     * <p>Executes the SQL query received as parameter</p>
     *
     * {@sample.xml ../../../doc/DBServer-connector.xml.sample dbserver:execute}
     *
     * @param sql query to be executed
     * @return result of the SQL query received
     */
    @Processor
    public Object execute(String sql)
    {
        Statement statement = null;
        try
        {
            statement = connection.createStatement();
            return statement.execute(sql);
        }
        catch (SQLException e)
        {
            logger.error("There has been a problem while executing the SQL statement", e);
            return null;
        }
    }

    /**
     * <p>Executes a SQL query</p>
     *
     * {@sample.xml ../../../doc/DBServer-connector.xml.sample dbserver:executeQuery}
     *
     * @param sql query to be executed
     * @return result of the SQL query in a JSON format.
     */
    @Processor
    public Object executeQuery(String sql)
    {
        Statement statement = null;
        try
        {
            return getMap(sql);
        }
        catch (SQLException e)
        {
            logger.error("There has been a problem while executing the SQL statement", e);
            return null;
        }
    }

    private List<Map<String, String>> getMap(String sql) throws SQLException
    {
        Statement statement;
        statement = connection.createStatement();
        ResultSet resultSet = statement.executeQuery(sql);
        List<Map<String, String>> jsonArray = new ArrayList<Map<String,String>>();
        ResultSetMetaData metaData = resultSet.getMetaData();
        while (resultSet.next())
        {
            HashMap<String, String> jsonObject = new HashMap<String,String>();
            for (int i = 1; i <= metaData.getColumnCount(); i++)
            {
                String columnName = metaData.getColumnName(i);
                jsonObject.put(columnName, String.valueOf(resultSet.getObject(columnName)));
            }
            jsonArray.add(jsonObject);
        }
        return jsonArray;
    }

    private Writer getResults(String sql) throws SQLException, IOException {
        Statement statement;
        statement = connection.createStatement();
        ResultSet resultSet = statement.executeQuery(sql);

        Writer writer = new StringWriter();
        CSVWriter csvwriter = new CSVWriter(writer);
        csvwriter.writeAll(resultSet,true);

        return writer;
    }

    /**
     * <p>Executes a SQL query</p>
     *
     * {@sample.xml ../../../doc/DBServer-connector.xml.sample dbserver:validateThat}
     *
     * @param query query to be executed
     * @param returns Expected value
     */
    @Processor
    public void validateThat(String query, String returns)
    {
        try
        {
            Writer writerQueryResult = getResults(query);
            assertEquals(writerQueryResult.toString().trim(), returns.replace("\\n", "\n"));
        }
        catch (ClassCastException ccException)
        {
            throw new RuntimeException("The JSON String must always be an array");
        }
        catch (SQLException e)
        {
            throw new RuntimeException("Invalid Query");
        }
        catch (IOException e)
        {
            throw new RuntimeException("Could no access to query results");
        }

    }

    /**
     * <p>Stops the server.</p>
     *
     * {@sample.xml ../../../doc/DBServer-connector.xml.sample dbserver:stop}
     */
    @Processor
    public void stopDbServer()
    {
        try
        {
            if ( connection != null ) connection.close();
        }
        catch (SQLException e)
        {
            throw new RuntimeException("Could not stop the database server", e);
        }
    }

    private void addJdbcToClassLoader() throws InstantiationException,
            IllegalAccessException, ClassNotFoundException
    {
        Class.forName("org.h2.Driver").newInstance();
    }

    public void setDatabase(String database)
    {
        this.database = database;
    }

    public void setSqlFile(String sqlFile)
    {
        this.sqlFile = sqlFile;
    }

    public void setCsv(String csv)
    {
        this.csv = csv;
    }

    public String getDatabase()
    {
        return database;
    }

    public String getSqlFile()
    {
        return sqlFile;
    }

    public String getCsv()
    {
        return csv;
    }
}
