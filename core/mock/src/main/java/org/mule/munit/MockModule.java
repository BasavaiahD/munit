/**
 * This file was automatically generated by the Mule Development Kit
 */
package org.mule.munit;

import org.mule.DefaultMuleMessage;
import org.mule.api.MuleContext;
import org.mule.api.MuleMessage;
import org.mule.api.NestedProcessor;
import org.mule.api.annotations.Module;
import org.mule.api.annotations.Processor;
import org.mule.api.annotations.param.Optional;
import org.mule.api.config.MuleProperties;
import org.mule.api.context.MuleContextAware;
import org.mule.api.el.ExpressionLanguageContext;
import org.mule.api.el.ExpressionLanguageExtension;
import org.mule.api.processor.MessageProcessor;
import org.mule.munit.common.endpoint.MockEndpointManager;
import org.mule.munit.common.endpoint.OutboundBehavior;
import org.mule.munit.common.mocking.MunitMocker;
import org.mule.munit.common.mocking.MunitSpy;
import org.mule.munit.common.mocking.MunitVerifier;
import org.mule.munit.functions.*;

import java.util.*;

/**
 * Generic module
 *
 * @author MuleSoft, Inc.
 */
@Module(name="mock", schemaVersion="3.3")
public class MockModule implements MuleContextAware, ExpressionLanguageExtension
{
    private MuleContext muleContext;


    /**
     * <p>Define what the mock must return on a message processor call.</p>
     * <p/>
     * <p>If the message processor doesn't return any value then there is no need to define an expect.</p>
     * <p/>
     * <p>You can define the message processor parameters in the same order they appear in the API documentation. In
     * order to define the behaviour on that particular case.</p>
     * <p/>
     * {@sample.xml ../../../doc/mock-connector.xml.sample mock:expect}
     *
     * @param messageProcessor Message processor name.
     * @param toReturn         Expected return value.
     * @param attributes       Message processor parameters.
     */
    @Processor
    public void expect(String messageProcessor,
                       MunitMuleMessage toReturn,
                       @Optional List<Attribute> attributes) {

        new MunitMocker(muleContext).expectMessageProcessor(getName(messageProcessor))
                .ofNamespace(getNamespace(messageProcessor))
                .withAttributes(createAttributes(attributes))
                .toReturn(createMuleMessageFrom(toReturn));
    }

    /**
     * <p>Define what the mock must return on a message processor call.</p>
     * <p/>
     * <p>If the message processor doesn't return any value then there is no need to define an expect.</p>
     * <p/>
     * <p>You can define the message processor parameters in the same order they appear in the API documentation. In
     * order to define the behaviour on that particular case.</p>
     * <p/>
     * {@sample.xml ../../../doc/mock-connector.xml.sample mock:spy}
     *
     * @param messageProcessor Message processor name.
     * @param assertionsBeforeCall Expected return value.
     * @param assertionsAfterCall  Message processor parameters.
     */
    @Processor
    public void spy(String messageProcessor,
                    @Optional List<NestedProcessor> assertionsBeforeCall,
                    @Optional List<NestedProcessor> assertionsAfterCall) {

            new MunitSpy(muleContext).spyMessageProcessor(getName(messageProcessor))
                    .ofNamespace(getNamespace(messageProcessor))
                    .running(createMessageProcessorsFrom(assertionsBeforeCall),
                            createMessageProcessorsFrom(assertionsAfterCall));
    }


    /**
     * <p>Expect to throw an exception when message processor is called. </p>
     * <p/>
     * {@sample.xml ../../../doc/mock-connector.xml.sample mock:expectFail}
     *
     * @param throwA Java Exception full qualified name.
     * @param when   Message processor name.
     */
//    @Processor
    public void expectFail(String when, String throwA) {
    }


    /**
     * Check that the message processor was called with some specified parameters
     * <p/>
     * {@sample.xml ../../../doc/mock-connector.xml.sample mock:verifyCall}
     *
     * @param messageProcessor Message processor Id
     * @param attributes       Message processor parameters.
     * @param times            Number of times the message processor has to be called
     * @param atLeast          Number of time the message processor has to be called at least.
     * @param atMost           Number of times the message processor has to be called at most.
     */
    @Processor
    public void verifyCall(String messageProcessor, @Optional List<Attribute> attributes,
                           @Optional Integer times,
                           @Optional Integer atLeast, @Optional Integer atMost) {

        MunitVerifier mockVerifier =
        new MunitVerifier(muleContext).verifyCallOfMessageProcessor(getName(messageProcessor))
                .ofNamespace(getNamespace(messageProcessor))
                .withAttributes(createAttributes(attributes));

        if (times != null) {
            mockVerifier.times(times);

        } else if (atLeast != null) {
            mockVerifier.atLeast(atLeast);
        } else if (atMost != null) {
            mockVerifier.atMost(atMost);
        } else {
            mockVerifier.atLeastOnce();
        }

    }

    /**
     * Reset mock behaviour
     *
     * {@sample.xml ../../../doc/mock-connector.xml.sample mock:outboundEndpoint}
     *
     * @param address the address
     * @param returnPayload the Return Payload
     * @param returnInboundProperties inbound properties
     * @param returnInvocationProperties invocation properties
     * @param returnSessionProperties invocation session properties
     * @param returnOutboundProperties oubound properties
     * @param assertions assertions
     */
    @Processor
    public void outboundEndpoint(String address,
                                 @Optional Object returnPayload,
                                 @Optional Map<String, Object> returnInvocationProperties,
                                 @Optional Map<String, Object> returnInboundProperties,
                                 @Optional Map<String, Object> returnSessionProperties,
                                 @Optional Map<String, Object> returnOutboundProperties,
                                 @Optional List<NestedProcessor> assertions) {

        MockEndpointManager factory = (MockEndpointManager) muleContext.getRegistry().lookupObject(MuleProperties.OBJECT_MULE_ENDPOINT_FACTORY);

        OutboundBehavior behavior = new OutboundBehavior(returnPayload, createMessageProcessorsFrom(assertions));

        behavior.setInboundProperties(returnInboundProperties);
        behavior.setInvocationProperties(returnInvocationProperties);
        behavior.setOutboundProperties(returnOutboundProperties);
        behavior.setSessionProperties(returnSessionProperties);

        factory.addBehavior(address, behavior);
    }



    @Override
    public void setMuleContext(MuleContext muleContext) {
        this.muleContext = muleContext;
    }

    @Override
    public void configureContext(ExpressionLanguageContext context) {
        context.declareFunction("eq", new EqMatcherFunction());
        context.declareFunction("anyBoolean", new AnyMatcherFunction(Boolean.class));
        context.declareFunction("anyByte", new AnyMatcherFunction(Byte.class));
        context.declareFunction("anyInt", new AnyMatcherFunction(Integer.class));
        context.declareFunction("anyDouble", new AnyMatcherFunction(Double.class));
        context.declareFunction("anyFloat", new AnyMatcherFunction(Float.class));
        context.declareFunction("anyShort", new AnyMatcherFunction(Short.class));
        context.declareFunction("anyObject", new AnyMatcherFunction(Object.class));
        context.declareFunction("anyString", new AnyMatcherFunction(String.class));
        context.declareFunction("anyList", new AnyMatcherFunction(List.class));
        context.declareFunction("anySet", new AnyMatcherFunction(Set.class));
        context.declareFunction("anyMap", new AnyMatcherFunction(Map.class));
        context.declareFunction("anyCollection", new AnyMatcherFunction(Collection.class));
        context.declareFunction("isNull", new NullMatcherFunction());
        context.declareFunction("isNotNull", new NotNullMatcherFunction());
        context.declareFunction("any", new AnyClassMatcherFunction());
        context.declareFunction("resultOfScript", new FlowResultFunction(muleContext));
    }


    private MuleMessage createMuleMessageFrom(MunitMuleMessage toReturn) {
        DefaultMuleMessage message = new DefaultMuleMessage(toReturn.getPayload(), muleContext);
        if ( toReturn.getInboundProperties() != null ){
            Map<String, Object> inboundProperties = toReturn.getInboundProperties();
            for (String property : inboundProperties.keySet() ){
                message.setInboundProperty(property, inboundProperties.get(property));
            }
        }

        if ( toReturn.getOutboundProperties() != null ){
            Map<String, Object> outboundProperties = toReturn.getOutboundProperties();
            for (String property : outboundProperties.keySet() ){
                message.setOutboundProperty(property, outboundProperties.get(property));
            }
        }

        if ( toReturn.getInvocationProperties() != null ){
            Map<String, Object> invocationProperties = toReturn.getInvocationProperties();
            for (String property : invocationProperties.keySet() ){
                message.setInvocationProperty(property, invocationProperties.get(property));
            }
        }

        if ( toReturn.getSessionProperties() != null ){
            Map<String, Object> sessionProperties = toReturn.getSessionProperties();
            for (String property : sessionProperties.keySet() ){
                message.setSessionProperty(property, sessionProperties.get(property));
            }
        }
        return message;
    }


    private List<MessageProcessor> createMessageProcessorsFrom(List<NestedProcessor> assertions) {
        if (assertions == null) {
            return null;
        }


        List<MessageProcessor> mps = new ArrayList<MessageProcessor>();
        for (NestedProcessor nestedProcessor : assertions) {
            mps.add(new NestedMessageProcessor(nestedProcessor));
        }

        return mps;
    }

    private Map<String, Object> createAttributes(List<Attribute> attributes) {
        Map<String, Object> attrs = new HashMap<String, Object>();
        if ( attributes == null ){
            return attrs;
        }

        for ( Attribute attr : attributes ){
            attrs.put(attr.getName(), attr.getWhereValue());
        }

        return attrs;
    }

    private String getNamespace(String when) {
        String[] split = when.split(":");
        if (split.length > 1) {
            return split[0];
        }

        return "mule";
    }

    private String getName(String when) {
        String[] split = when.split(":");
        if (split.length > 1) {
            return split[1];
        }

        return split[0];
    }


}
